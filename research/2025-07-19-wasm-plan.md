# WASM Integration Plan for SZDT Library

*Date: 2025-01-19*

## Overview

This document outlines the plan for exposing core SZDT Rust library functionality as a WebAssembly (WASM) library for JavaScript/TypeScript environments. The focus is on cryptographic operations, data structures, and serialization while excluding CLI-specific functionality like archiving.

## Core Modules for WASM Export

### 1. Key Material Operations (`ed25519_key_material.rs`)
- `Ed25519KeyMaterial::generate()` - Generate new key material
- `Ed25519KeyMaterial::from_seed(seed)` - Create from seed
- `Ed25519KeyMaterial::from_mnemonic(mnemonic)` - Create from mnemonic
- `Ed25519KeyMaterial::did()` - Get DID key
- `Ed25519KeyMaterial::sign(data)` - Sign data
- `Ed25519KeyMaterial::verify(data, signature)` - Verify signatures

### 2. Hash Operations (`hash.rs`)
- `Hash::new(data)` - Blake3 hashing
- `Hash::from_reader()` - Streaming hash computation
- `Hash::from_bytes()` - Create from byte array
- `Hash::as_bytes()` - Get hash bytes
- `Hash::to_string()` - Base32 representation

### 3. DID Key Management (`did.rs`)
- `DidKey::new(pubkey_bytes)` - Create DID from public key
- `DidKey::parse(did_key_url)` - Parse DID:key URLs
- `DidKey::to_string()` - Serialize DID to string

### 4. Memo Operations (`memo.rs`)
- `Memo::new(body_hash)` - Create new memo
- `Memo::for_body(content)` - Create memo for content
- `Memo::sign(key_material)` - Sign memo
- `Memo::verify()` - Verify memo signature
- `Memo::validate(timestamp)` - Full validation including time checks

### 5. Serialization (`cbor_seq.rs`, `bytes.rs`)
- `CborSeqWriter` - CBOR sequence writing
- `CborSeqReader` - CBOR sequence reading
- Bytes wrapper for binary data

## WASM Architecture

### 1. Cargo.toml Configuration

```toml
[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
js-sys = "0.3"
web-sys = "0.3"
serde-wasm-bindgen = "0.6"
```

### 2. WASM API Structure

The approach is to expose methods directly on the original Rust structs using `#[wasm_bindgen]` implementations, avoiding wrapper types for clean JavaScript APIs.

### 3. Key Features to Expose

#### Ed25519KeyMaterial API (Direct exposure)
```rust
#[wasm_bindgen]
impl Ed25519KeyMaterial {
    #[wasm_bindgen]
    pub fn generate() -> Ed25519KeyMaterial
    
    #[wasm_bindgen]
    pub fn from_seed(seed: &[u8]) -> Result<Ed25519KeyMaterial, JsError>
    
    #[wasm_bindgen]
    pub fn from_mnemonic(mnemonic: &str) -> Result<Ed25519KeyMaterial, JsError>
    
    #[wasm_bindgen]
    pub fn did_string(&self) -> String
    
    #[wasm_bindgen]
    pub fn sign(&self, data: &[u8]) -> Result<Vec<u8>, JsError>
    
    #[wasm_bindgen]
    pub fn verify(&self, data: &[u8], signature: &[u8]) -> Result<bool, JsError>
}
```

#### Hash API (Direct exposure)
```rust
#[wasm_bindgen]
impl Hash {
    #[wasm_bindgen(constructor)]
    pub fn new(data: &[u8]) -> Hash
    
    #[wasm_bindgen]
    pub fn from_bytes(bytes: &[u8]) -> Result<Hash, JsError>
    
    #[wasm_bindgen]
    pub fn as_bytes(&self) -> Vec<u8>
    
    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String
}
```

#### Memo API (Direct exposure)
```rust
#[wasm_bindgen]
impl Memo {
    #[wasm_bindgen(constructor)]
    pub fn new(body_hash: &Hash) -> Memo
    
    #[wasm_bindgen]
    pub fn for_body(content: &[u8]) -> Result<Memo, JsError>
    
    #[wasm_bindgen]
    pub fn sign(&mut self, key_material: &Ed25519KeyMaterial) -> Result<(), JsError>
    
    #[wasm_bindgen]
    pub fn verify(&self) -> Result<bool, JsError>
    
    #[wasm_bindgen]
    pub fn validate(&self, timestamp: Option<u64>) -> Result<bool, JsError>
    
    #[wasm_bindgen]
    pub fn to_cbor(&self) -> Result<Vec<u8>, JsError>
    
    #[wasm_bindgen]
    pub fn from_cbor(data: &[u8]) -> Result<Memo, JsError>
    
    #[wasm_bindgen]
    pub fn checksum(&self, body_hash: &Hash) -> Result<bool, JsError>
}
```

### 4. TypeScript Definitions

Generate comprehensive TypeScript definitions using `wasm-bindgen` for:
- Ed25519KeyMaterial management (directly on Ed25519KeyMaterial class)
- Hash operations (directly on Hash class)
- Memo operations (directly on Memo class)
- DID key operations
- CBOR serialization/deserialization

### 5. Build Configuration

- Use `wasm-pack` for building and packaging
- Target both Node.js and browser environments
- Optimize for size with `wee_alloc` and `lto = true`
- Consider splitting into multiple WASM modules if size becomes an issue

### 6. JavaScript/TypeScript Usage Example

```typescript
import { Hash, Memo, Ed25519KeyMaterial } from './szdt_wasm';

// Direct hash usage
const data = new Uint8Array([1, 2, 3, 4]);
const hash = new Hash(data);
console.log(hash.toString()); // Base32 representation
const hashBytes = hash.as_bytes();

// Direct key material usage
const keyMaterial = Ed25519KeyMaterial.generate();
console.log(keyMaterial.did_string());

// Direct memo usage
const memo = new Memo(hash);
memo.sign(keyMaterial);
const isValid = memo.verify();

// Or create memo from content
const memo2 = Memo.for_body(data);
memo2.sign(keyMaterial);
const cborData = memo2.to_cbor();
```

## Implementation Notes

### Excluded Functionality
- Archive creation and reading operations (CLI-specific)
- File system operations
- Database operations

### Design Principles
- **Direct exposure**: Expose methods directly on original structs rather than creating wrapper types
- **Clean APIs**: Provide ergonomic JavaScript/TypeScript interfaces
- **Memory safety**: Ensure proper memory management in WASM context
- **Error handling**: Convert Rust Result types to JavaScript exceptions appropriately
- **Type safety**: Generate comprehensive TypeScript definitions

### Future Considerations
- Streaming interfaces using Web Streams API for large data processing
- Async/await patterns for computationally heavy operations
- Progressive loading strategies if bundle size becomes an issue
- Integration with existing JavaScript cryptography libraries where beneficial

This architecture provides the core SZDT functionality in a clean, type-safe manner suitable for web and Node.js applications while maintaining the security and integrity features of the original Rust implementation.